worker_processes auto;

events {
    worker_connections 1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile      on;
    keepalive_timeout 65;

    server {
      listen 80;
      server_name localhost;

      root /usr/share/nginx/html;
      index index.html;

      location / {
          try_files $uri $uri/ /index.html;
      }

      error_page 500 502 503 504 /50x.html;
      location = /50x.html {
          root /usr/share/nginx/html;
      }
    }

    server {
    listen 80;
    server_name api.imaginarystorage.com;

    # proxy /api/* to backend
    location / {
        proxy_pass http://backend;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # hide backend internals
        proxy_hide_header X-Powered-By;
        proxy_hide_header Server;
    }

    }

    server {
        listen 80;
        server_name res.imaginarystorage.com;

        # max file size upload if used via nginx
        client_max_body_size 4G;

        # Cache static responses (for public files). Tune TTL per your use-case.
        proxy_cache_path /var/cache/nginx/res_cache levels=1:2 keys_zone=res_cache:100m max_size=10g inactive=24h use_temp_path=off;

        # First, handle internal accelerated redirects
        # location /internal_storage/ {
        #     internal;  # only internal redirects may hit here
        #     # Map to an on-disk mount if you sync files locally, or alias to a path
        #     alias /var/storage_origin/; # ensure docker-compose mounts this dir to nginx
        #     # don't expose directory listings
        #     autoindex off;
        #     # set cache headers for CDN
        #     add_header Cache-Control "public, max-age=31536000, immutable";
        #     try_files $uri =404;
        # }

        # Public origin route: proxy to the proxy_service which hides real provider URLs
        location / {
            # optional caching at Nginx for GET responses
            proxy_cache res_cache;
            proxy_cache_valid 200 302 10m;
            proxy_cache_valid 404 1m;
            proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;

            proxy_pass http://proxy_service;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # Remove backend headers that might leak origin provider info (e.g. S3 headers)
            proxy_hide_header x-amz-id-2;
            proxy_hide_header x-amz-request-id;
            proxy_hide_header x-amz-version-id;
            proxy_hide_header x-amz-server-side-encryption;
            proxy_hide_header Server;
            proxy_hide_header Date;

            # Prevent passing Authorization upstream (unless you want)
            proxy_set_header Authorization "";

            # Important: pass any internal redirect header straight through (so proxy can return X-Accel-Redirect)
            # Nginx will process X-Accel-Redirect automatically if proxy returns it
        }

        # Optionally reject direct host header mismatches, enforce referer or token checks at Nginx layer if needed
    }

}
