backend tasks:

1. generate previews of different files ands save it to storage and db
  - implemnatation logic:
    - previes are getting saved to the same storage as files
    - a new folder '.imaginary' is created in root path to save all previews
    - after saving preview file its object is also created in db which is used to fetch preview under proxy server
    - we show preview conditionally:
    - if preview is generated for the file then we show that preview
    - if preview is not generated but its a image file then we show image itself as preview
    - for other files we show default file preview icon
    - currently supported preview file types are: images, videos, pdfs, audio
    - for some of the files we need system level dependencies like ffmpeg for video and audio preview generation
    - for this we need to install those dependencies first
    - also updated the docker file to include those dependencies in docker image

2. implement copy move logic for files and folders:
  - implemnatation logic:
    - backend:
      - copy command:
        - input: sourceIds[], destinationFolderId
        - for each sourceId:
          - fetch destination folder metadata from db
            - validate if destination folder exists
          - fetch file/folder metadata from db
            - if file:
              - generate new unique file name
              - copy file in storage from old path to new path (new path is generated using destinationFolderId and new unique file name)
              - create new file metadata in db with new unique filename, new path, parentFolderId as destinationFolderId
            - if folder:
              - create new folder in db with parentFolderId as destinationFolderId
              - fetch all files and folders under this folder recursively
              - for each file and folder:
                - if file:
                  - generate new unique file name
                  - copy file in storage from old path to new path (new path is generated using new parent folder path and new unique file name)
                  - create new file metadata in db with new unique filename, new path, parentFolderId as new parent folder id
                - if folder:
                  - create new folder in db with parentFolderId as new parent folder id
          - return errors if any during the process

      - move command:
        - input: sourceIds[], destinationFolderId
        - for each sourceId:
          - fetch destination folder metadata from db
            - validate if destination folder exists
          - fetch file/folder metadata from db
            - if file:
              - generate new unique file name
              - move file in storage from old path to new path (new path is generated using destinationFolderId and new unique file name)
              - update file metadata in db with new unique filename, new path, parentFolderId as destinationFolderId
            - if folder:
              - update folder in db with parentFolderId as destinationFolderId
              - fetch all files and folders under this folder recursively
              - for each file and folder:
                - if file:
                  - generate new unique file name
                  - move file in storage from old path to new path (new path is generated using new parent folder path and new unique file name)
                  - update file metadata in db with new unique filename, new path, parentFolderId as new parent folder id
                - if folder:
                  - update new folder in db with parentFolderId as new parent folder id
          - return errors if any during the process


    - issues:
      - when moving folder in another folder which have a subfolder with same name, it creates conflict
        - solution:
          1.  while moving folder, if destination folder already have a subfolder with same name, we can append a unique identifier to the folder name to avoid conflict
            - e.g. if moving folder 'Documents' to another folder which already have 'Documents' folder, we can rename the new folder to 'Documents_1' or 'Documents_<uniqueId>'
          2. another approach is to merge the contents of both folders
            - e.g. if moving folder 'Documents' to another folder which already have 'Documents' folder, we can merge the contents of both folders
            - this approach is complex as we need to handle conflicts for files and subfolders as well
          3. for now, we will go with first approach as its simpler to implement and understand
          4. we can also notify user about the renaming of folder to avoid confusion
    
3. implement delete logic for files and folders
  - implementation logic:
    - soft delete:
      - input: sourceIds[]
      - for each sourceId:
        - fetch file/folder metadata from db
          - if file:
            - mark file as deleted in db (set deletedAt timestamp)
          - if folder:
            - fetch all files and folders under this folder recursively
            - for each file and folder:
              - if file:
                - mark file as deleted in db (set deletedAt timestamp)
              - if folder:
                - mark folder as deleted in db (set deletedAt timestamp)
        - return errors if any during the process

    - hard delete:
      - input: sourceIds[]
      - for each sourceId:
        - fetch file/folder metadata from db
          - if file:
            - delete file from storage
            - delete file metadata from db
          - if folder:
            - fetch all files and folders under this folder recursively
            - for each file and folder:
              - if file:
                - delete file from storage
                - delete file metadata from db
              - if folder:
                - delete folder metadata from db
        - return errors if any during the process

4. implement sharing logic for files
5. implement get file details api